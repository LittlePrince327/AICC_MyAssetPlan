# -*- coding: utf-8 -*-
"""Make_Query.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X8nor-ecKlHdy6Zced46_q0E8dc0KHp7
"""

import re
import time
import pytz
import calendar
from datetime import datetime, timedelta, date
from dateutil.relativedelta import relativedelta

from konlpy.tag import Okt, Kkma
from pykospacing import Spacing
from soynlp.normalizer import repeat_normalize

import Chatbot_Entity_date as ed
from  economic_entity import extract_finance_entities, extract_stock_entities

from transformers import AutoTokenizer, AutoModelForSequenceClassification

import torch

from pykospacing import Spacing
import re


okt = Okt()
kkma = Kkma()
spacing = Spacing()
kst = pytz.timezone('Asia/Seoul')

# 모델 경로
# model_dir = r"C:\Users\4호실-8\Desktop\Chatbot_intent_KF-DeBERTa_tokenizer"

# 로컬 경로에서 모델과 토크나이저 로드
# tokenizer = AutoTokenizer.from_pretrained(model_dir)
# model = AutoModelForSequenceClassification.from_pretrained(model_dir, num_labels=3)

FAQ_LINK = "FAQ 링크"
MAP_LINK = "자산 링크"
EI_LINK  = "경제지표 링크"
PS_LINK  = "주가예측 링크"

# 텍스트 전처리
def processe_text(text):
    text = spacing(text)
    text = re.sub(r"[^가-힣a-zA-Z0-9\s]", "", text)
    text = repeat_normalize(text, num_repeats=3)
    text = re.sub(r'\s+', ' ', text).strip()

    return text

# def predict_label(text, model, tokenizer):
#     text = processe_text(text)
#     # 토큰화
#     inputs = tokenizer(text, return_tensors="pt", padding="max_length", truncation=True, max_length=512)
#     # 모델 예측
#     outputs = model(**inputs)
#     probs = torch.softmax(outputs.logits, dim=-1)
#     pred = torch.argmax(probs, dim=1).item()

#     label_map = {0: 'stock', 1: 'finance', 2: 'FAQ'}
#     return label_map[pred]

# 예시 문장 입력
# example_sentence = "보안문제를 해결하고 싶어요"
# predicted_label = predict_label(example_sentence, model, tokenizer)

# 소비, 수입, 입출금 등을 위한 패턴
def process_date_format(input_date, date_type="%Y-%m-%d", date_query="AND rp_date IN ("):
    """
    주어진 날짜 형식(input_date)에 맞춰 SQL 쿼리 문자열을 생성하는 함수.
    'yyyy-mm-dd', 'yyyy-mm', 'yyyy' 형식의 날짜를 처리하며, 날짜 형식에 따라 다른 쿼리 형식을 반환한다.

    Args:
    input_date (list): 날짜 정보가 포함된 리스트. 'yyyy-mm-dd', 'yyyy-mm', 또는 'yyyy' 형식.
    date_type (str): 날짜의 포맷. 기본값은 None이며, input_date가 없을 경우 오늘 날짜로 설정할 때 사용됨.
    date_query (str): 기본 SQL 쿼리 문자열. 기본값은 "AND rp_date IN (". ->

    Returns:
    str: SQL 쿼리 형식의 문자열.
    """

    if input_date == None or input_date == []:
        input_date = []
        date = datetime.strftime(datetime.today(), date_type)
        input_date.append(date)
    if len(input_date[0]) == 10: # 형식이 'yyyy-mm-dd'
        date_query = date_query
        for i in input_date:
            date_query += f'"{i}", '
        date_query = date_query.rstrip()
        date_query = date_query[:-1] + ")"
        return date_query

    elif len(input_date[0]) == 7:  # 형식이 'yyyy-mm'
        date_query = "AND "
        for i in input_date:
            date_query += f'rp_date LIKE "{i}%" OR '
        date_query = date_query[:-4]
        return date_query

    elif len(input_date[0]) == 4:  # 형식이 'yyyy'
        date_query = "AND "
        for i in input_date:
            date_query += f'rp_date LIKE "{i}%" OR '
        date_query = date_query[:-4]
        return date_query
    else:
        date = datetime.strftime(datetime.today(), date_type)
        date_query += f'"{date}", '
        date_query = date_query.rstrip(", ") + ")"
        return date_query

# 주식 수량을 위한 패턴
def process_date_format_stock_qty(input_date, date_type='%Y-%m-%d'):
    if input_date == None:
        input_date = [datetime.strftime(datetime.today(), date_type)]  # 오늘

    if len(input_date[0]) == 10:  # 형식이 'yyyy-mm-dd'
        date_query = f"AND sh_date <= '{input_date[0]}'"
        return date_query

    elif len(input_date[0]) == 7:  # 형식이 'yyyy-mm'
        year, month = map(int, input_date[0].split('-'))
        last_day = calendar.monthrange(year, month)[1]  # 그 달의 마지막 날 계산
        end_date = datetime(year, month, last_day).strftime('%Y-%m-%d')  # 그 달의 마지막 날
        date_query = f"AND sh_date <= '{end_date}'"
        return date_query

    elif len(input_date[0]) == 4:  # 형식이 'yyyy'
        year = int(input_date[0])
        end_date = datetime(year, 12, 31).strftime('%Y-%m-%d')  # 그 해의 12월 31일
        date_query = f"AND sh_date <= '{end_date}'"
        return date_query
    else:
        end_date = datetime.strftime(datetime.today(), date_type)
        date_query = f"AND sh_date <= '{end_date}'"
        return date_query

def generate_query_expend(ent1, rp_part, add_query, date_query, query_type):
    # 기본 쿼리 템플릿
    base_query = (
        "SELECT rp_date, rp_detail, rp_amount "
        "FROM tb_received_paid "
        "WHERE user_id = {{user_id}} AND rp_part = {rp_part} {add_query} {date_query} "
    ).format(rp_part=rp_part, add_query=add_query, date_query=date_query)

    # 'frequent' 타입은 특별한 쿼리 구조를 가짐
    if query_type == 'frequent':
        frequent_query = (
            "AND rp_detail IN ("
            "SELECT rp_detail FROM tb_received_paid "
            "WHERE user_id = {{user_id}} AND rp_part = {rp_part} {add_query} {date_query} "
            "GROUP BY rp_detail HAVING COUNT(*) >= 3 ORDER BY COUNT(*) DESC"
            ") "
            "ORDER BY rp_detail DESC, rp_amount LIMIT 3;"
        ).format(rp_part=rp_part, add_query=add_query, date_query=date_query)
        return base_query + frequent_query

    # 쿼리 타입에 따른 ORDER BY 절과 LIMIT 값을 매핑
    query_mapping = {
        'highest': {'order_by': 'rp_amount DESC', 'limit': 1},
        'top5': {'order_by': 'rp_amount DESC', 'limit': 5},
        'lowest': {'order_by': 'rp_amount ASC', 'limit': 1},
        'bottom5': {'order_by': 'rp_amount ASC', 'limit': 5},
    }

    # 매핑된 쿼리 타입 처리
    if query_type in query_mapping:
        order_by = query_mapping[query_type]['order_by']
        limit = query_mapping[query_type]['limit']
        return base_query + f"ORDER BY {order_by} LIMIT {limit}"

    return None

def generate_query_입출금(detail, add_query, date_query, order_by=None, limit=None):
    base_query = f'SELECT rp_date, rp_detail, rp_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_detail = "{detail}" {add_query} {date_query}'
    if order_by:
        base_query += f' ORDER BY rp_amount {order_by}'
    if limit:
        base_query += f' LIMIT {limit}'
    return base_query

def finance_pattern_query(finance_query, input_time=None, entity1=None, entity2=None, date_query=None, text=None):
    print("텍스트:", text)
    print("재무쿼리?:", finance_query)
    print("앤티티1:", entity1)
    print("앤티티2:", entity2)
    query = {}
    add_query = "AND rp_hold = 0" if text and "고정" in text or "고 정" in text else ""
    print("애드쿼리:", add_query)
    add_str = "고정" if add_query else ""
    print(f"add_str: {add_str}")

    if finance_query == "지출" or finance_query == "소득" or r'구매|구입|\b산\b' in text:
        for ent1 in entity1:
            for ent2 in entity2:

                if ent2[1] == "sum":
                    rp_part = 1 if finance_query == "지출" or r'구매|구입|\b산\b' in text else 0
                    query[f'{add_str}{ent1[1]}_sum'] = f'SELECT SUM(rp_amount) as Total_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_part = {rp_part} {add_query} ' + date_query
                elif ent2[1] == "average":
                    rp_part = 1 if finance_query == "지출" or r'구매|구입|\b산\b' in text else 0
                    query[f'{add_str}{ent1[1]}_average'] = f'SELECT AVG(rp_amount) as Average_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_part = {rp_part} {add_query} ' + date_query
                elif ent2[1] == "sort":
                    rp_part = 1 if finance_query == "지출" or r'구매|구입|\b산\b' in text else 0
                    if any(word in text for word in ["큰", "크게", "높은"]):
                        if any(word in text for word in ["가장", "최고", "제일"]):
                            query[f'{add_str}{ent1[1]}_highest'] = generate_query_expend(ent1, rp_part, add_query, date_query, 'highest')
                            break
                        query[f'{add_str}{ent1[1]}_top5'] = generate_query_expend(ent1, rp_part, add_query, date_query, 'top5')

                    elif any(word in text for word in ["작은", "적게", "낮은", "적은", "작게"]):
                        if any(word in text for word in ["가장", "최고", "제일"]):
                            query[f'{add_str}{ent1[1]}_lowest'] = generate_query_expend(ent1, rp_part, add_query, date_query, 'lowest')
                            break
                        query[f'{add_str}{ent1[1]}_bottom5'] = generate_query_expend(ent1, rp_part, add_query, date_query, 'bottom5')

                    elif any(word in text for word in ["자주", "많이", "빈번", "반복", "주요", "많은"]):
                        query[f'{add_str}{ent1[1]}_frequent'] = generate_query_expend(ent1, rp_part, add_query, date_query, 'frequent')

                elif ent2[1] == "simple":  # None일 때 sum, average, sort 조건 제외한 쿼리만 추가
                    rp_part = 1 if finance_query == "지출" or r'구매|구입|\b산\b' in text else 0
                    query[f'{add_str}{ent1[1]}_simple'] = "SELECT rp_date, rp_detail, rp_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_part = 1 {}".format(date_query)
    elif finance_query == "BUDGET":
        current_date = datetime.today()
        current_year = current_date.year
        if re.fullmatch(r'\d{4}-\d{1,2}', input_time):
            input_date = datetime.strptime(input_time, "%Y-%m")
            this_month = current_date.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
            print(f"input_date {input_date}")
            if input_date < this_month:
                query["과거 예산 조회"] = '과거 예산 조회가 불가능합니다'
            elif input_date > this_month:
                query["예산추천"] = (
                    'SELECT rp_amount FROM tb_received_paid '
                    'WHERE rp_date BETWEEN DATE_ADD(NOW(), INTERVAL -3 MONTH) AND NOW() AND rp_part = 1'
                )
            else:
                query["예산"] = (
                    f'SELECT uf_target_budget FROM tb_user_finance WHERE user_id = {{user_id}}'
                )
                query["사용한 금액"] = (
                    f'SELECT rp_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_date IN ({input_time})'
                )

        elif re.fullmatch(r'\d{4}', input_time):
            input_year = int(input_time)

            if input_year < current_year:
                start_year = input_year - 3
                query["과거3년평균"] = (
                    f'SELECT AVG(rp_amount) AS average_amount FROM tb_received_paid '
                    f'WHERE YEAR(rp_date) BETWEEN {start_year} AND {input_year} AND rp_part = 1'
                )
            elif input_year > current_year:
                query["예산추천"] = (
                    'SELECT rp_amount FROM tb_received_paid '
                    'WHERE rp_date BETWEEN DATE_ADD(NOW(), INTERVAL -3 YEAR) AND NOW() AND rp_part = 1'
                )
            else:
                query["예산"] = (
                    f'SELECT uf_target_budget FROM tb_user_finance WHERE user_id = {{user_id}}'
                )
    elif finance_query == "DEPOSIT_SAVINGS":
        detail_conditions = {
            "예금": "rp_detail = '예금'",
            "적금": "rp_detail = '적금'",
            "예적금": "(rp_detail = '예금' OR rp_detail = '적금')"
        }
        for i in range(len(entity1)):
            detail_query = detail_conditions.get(entity1[i][0], "")

            if entity2[0][1] == "stats":
                query[f'{entity1[i][0]}'] = f'SELECT rp_date, rp_detail, rp_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_part = 1 AND {detail_query} {date_query}'
                query[f'{entity2[i][0]}'] = f'SELECT rp_detail, SUM(rp_amount) AS Total_Amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_part = 1 AND {detail_query} {date_query}'
            elif entity2[0][1] in ["sum", "date"]:
                sum_or_date = "SUM(rp_amount) AS Total_Amount" if entity2[0][1] == "sum" else "rp_date, rp_amount"
                query[f'{entity2[i][0]}'] = f'SELECT rp_detail, {sum_or_date} FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_part = 1 AND {detail_query} {date_query}'
            else:
                query[f'{entity1[i][0]}'] = f'SELECT rp_date, rp_detail, rp_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_part = 1 AND {detail_query} {date_query}'

        return query
    elif finance_query == "입출금":
        def is_deposit(text, e1):
            return "입금" in text or any(word in text for word in ["들어온", "받은"])

        def is_withdrawal(text, e1):
            return e1 in ["출금", "납부", "인출"] or any(word in text for word in ["나간", "보낸"])

        for i in range(len(entity1)):
            print("입출금엔티티2:", entity2)
            e1 = entity1[i][0]
            try:
                e2 = entity2[i][1]
            except:
                try:
                    e2 = entity2[i]
                except:
                    e2 = None
            if e2 == "sum":
                if is_deposit(text, e1):
                    query[f"{add_str}{e1}"] = f'SELECT SUM(rp_amount) as Total_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_detail = "입금" {add_query} {date_query}'
                elif is_withdrawal(text, e1):
                    query[f"{add_str}{e1}"] = f'SELECT SUM(rp_amount) as Total_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_detail = "출금" {add_query} {date_query}'

            elif e2 == "sort":
                if any(word in text for word in ["큰", "크게", "높은"]):
                    sort_order = "DESC"
                elif any(word in text for word in ["작은", "적게", "낮은", "적은", "작게"]):
                    sort_order = "ASC"
                else:
                    sort_order = None

                limit = "1" if any(word in text for word in ["가장", "최고", "제일"]) else "5"

                if is_deposit(text, e1):
                    query[f"{add_str}{e1}"] = generate_query_입출금("입금", add_query=add_query, date_query=date_query, order_by=sort_order, limit=limit)
                elif is_withdrawal(text, e1):
                    query[f"{add_str}{e1}"] = generate_query_입출금("출금", add_query=add_query, date_query=date_query, order_by=sort_order, limit=limit)

            elif e2 == "average":
                if is_deposit(text, e1):
                    query[f"{add_str}{e1}"] = f'SELECT AVG(rp_amount) as Average_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_detail = "입금" {add_query} {date_query}'
                elif is_withdrawal(text, e1):
                    query[f"{add_str}{e1}"] = f'SELECT AVG(rp_amount) as Average_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_detail = "출금" {add_query} {date_query}'

            else:
                if is_deposit(text, e1):
                    query[f"{add_str}{e1}"] = f'SELECT rp_date, rp_detail, rp_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_detail = "입금" {add_query} {date_query}'
                elif is_withdrawal(text, e1):
                    query[f"{add_str}{e1}"] = f'SELECT rp_date, rp_detail, rp_amount FROM tb_received_paid WHERE user_id = {{user_id}} AND rp_detail = "출금" {add_query} {date_query}'
    elif finance_query == "ASSET":
        query["링크"] = MAP_LINK
    elif finance_query == "LOAN":
        for _ in range(len(entity1)):
            if "대출상환" in text:
                query['대출상환'] = 'SELECT rp_date, rp_detail, rp_amount FROM tb_received_paid WHERE user_id = {{user_id}} rp_detail = "대출 상환"' + " " + date_query
                text = text.replace("상환", "", 1)
            elif "대출":
                query['대출'] = 'SELECT uf_loan FROM tb_user_finance WHERE user_id = {user_id}'
            else:
                pass
    elif finance_query == "ALL":
        query[f'전체내역'] = 'SELELT rp_date, rp_detail, rp_amount FROM tb_received_paid WHERE user_id = {user_id}' + " " + date_query
    return query

def pattern_stock(entity, input_date, text=None):  # [('삼성', 'STOCK'), ('애플', 'STOCK'), ('산', 'buy')]
    query, entity_list, entity_str = {}, [], ''
    buy = r"구매|구입|매입|매수|투자|사고|\b산\b"
    sell = r"판매|매도|\b판\b|처분|팔고"
    stock_mapping = {"삼성": "sh_ss_count", "삼전": "sh_ss_count", "samsung": "sh_ss_count",
                    "애플": "sh_ap_count", "apple": "sh_ap_count",
                    "비트코인": "sh_bit_count", "코인": "sh_bit_count", "bitcoin": "sh_bit_count", "coin": "sh_bit_count"}

    for i, j in entity:
        if i in stock_mapping:
            entity_list.append(stock_mapping[i])
            break
        for stock in entity_list:
            entity_str += f'{str(stock)}, '

    if sell in text and buy in text:
        date_query = process_date_format(input_date, date_query="AND sh_date IN (")
        if len(entity_list) == 0:
            query['주식거래'] = 'SELECT sh_date, sh_ss_count, sh_ap_count, sh_bit_count FROM tb_shares_held WHERE user_id = {{user_id}}' + date_query
        elif len(entity_list) == 1:
            query[f'{entity_list[0]}거래'] = f'SELECT {entity_str} FROM tb_shares_held' + ' WHERE user_id = {{user_id}}' + date_query
        else:
            for i in range(len(entity_list)):
                query[f'{entity_list[i]}거래'] = f'SELECT {entity_str} FROM tb_shares_held' + ' WHERE user_id = {{user_id}}' + date_query
        return query
    elif buy in text:
        date_query = process_date_format(input_date, date_query="AND sh_date IN (")
        if len(entity_list) == 0:
            query['주식구매'] = 'SELECT sh_date, sh_ss_count, sh_ap_count, sh_bit_count FROM tb_shares_held WHERE user_id = {{user_id}} AND (sh_ss_count > 0 OR sh_ap_count > 0 OR sh_bit_count > 0)' + " " + date_query
        elif len(entity_list) == 1:
            query[f'{entity_list[0]}구매'] = f'SELECT {entity_str} FROM tb_shares_held' + ' WHERE user_id = {{user_id}}' + f' AND {entity_list[0]} > 0' + " " + date_query
        else:
            for i in range(len(entity_list)):
                query[f'{entity_list[i]}구매'] = f'SELECT {entity_str} FROM tb_shares_held' + ' WHERE user_id = {{user_id}}' + f' AND {entity_list[i]} > 0' + " " + date_query
        return query
    elif sell in text:
        date_query = process_date_format(input_date, date_query="AND sh_date IN (")
        if len(entity_list) == 0:
            query['주식판매'] = 'SELECT sh_date, sh_ss_count, sh_ap_count, sh_bit_count FROM tb_shares_held WHERE user_id = {{user_id}} AND (sh_ss_count < 0 OR sh_ap_count < 0 OR sh_bit_count < 0)' + " " + date_query
        elif len(entity_list) == 1:
            query[f'{entity_list[0]}판매'] = f'SELECT {entity_list[0]} FROM tb_shares_held' + ' WHERE user_id = {{user_id}}' + f' AND {entity_list[0]} < 0' + " " + date_query
        else:
            for i in range(len(entity_list)):
                query[f'{entity_list[i]}판매'] = f'SELECT {entity_list[i]} FROM tb_shares_held' + ' WHERE user_id = {{user_id}}' + f' AND {entity_list[i]} < 0' + " " + date_query
        return query
    else:
        date_query = process_date_format_stock_qty(input_date, date_type="%Y-%m-%d")
        if len(entity_list) == 0:
            query['주식내역'] = 'SELECT sh_date, SUM(sh_ss_count) as total_ss, SUM(sh_ap_count) as total_ap, SUM(sh_bit_count) as total_bit FROM tb_shares_held WHERE user_id = {{user_id}}' + " " + date_query
        elif len(entity_list) == 1:
            query[f'{entity_list[0]}주식내역'] = f'SELECT SUM({entity_list[0]}) as total_{entity_list[0]} FROM tb_shares_held WHERE user_id = {{user_id}} {date_query}'
        else:
            for i in range(len(entity_list)):
                query[f'{entity_list[i]}주식내역'] = f'SELECT SUM({entity_list[i]}) as total_{entity_list[i]} FROM tb_shares_held WHERE user_id = {{user_id}} {date_query}'
        return query

# 앤티티 2개일때, 1개만 남기기
def filter_entities(entities):
    entity_map = {
        "자산": 0,             # 보유|자산|재정|재무|자본|재산|잔고
        "가계부": 0,               # 가계부 등
        "주식": 2,             # 주식|삼성|삼전|애플|코인|비트코
        "저축": 2,   # 적금|예금|저축
        "대출": 2,              # 대출
        "소득": 2,            # 수입|소득|월급|급여
        "예산": 2,            # 예산
        "입출금": 1,       # 입출금|입금|출금|이체|송금|인출|납부
        "지출": 1        # 지출|소비|쓴|사용|결제|카드
    }

    vs = []
    for i in entities:
        a = {i : entity_map[i]}
        vs.append(a)

    vs2 = {}
    for i in vs:
        if len(vs2) != 0:
            ivalue = list(i.values())
            vs2value = list(vs2.values())
            if ivalue[0] > vs2value[0]:
                vs2.clear()
                vs2[list(i.keys())[0]] = list(i.values())[0]
            elif ivalue[0] == vs2value[0]:
                vs2[list(i.keys())[0]] = list(i.values())[0]
        else:
            vs2[list(i.keys())[0]] = list(i.values())[0]
    return list(vs2.keys())

def process_fixed_dates_original(input_date, text):
    input_dates = []

    # "고정"이 text에 포함된 경우 처리
    if "고정" in text:
        for x in range(len(input_date)):
            today_str = datetime.now(kst).strftime("%Y-%m-%d" if len(input_date[x]) == 10 else "%Y-%m" if len(input_date[x]) == 7 else "%Y")
            today = datetime.strptime(today_str, "%Y-%m-%d" if len(today_str) == 10 else "%Y-%m" if len(input_date[x]) == 7 else "%Y")
            input_date_compare = datetime.strptime(input_date[x], "%Y-%m-%d" if len(input_date[x]) == 10 else "%Y-%m" if len(input_date[x]) == 7 else "%Y")

            # input_date가 현재 날짜보다 미래인 경우
            if input_date_compare > today:
                for day in input_date:
                    day_str = str(day)
                    day = datetime.strptime(day, {10: "%Y-%m-%d", 7: "%Y-%m", 4: "%Y"}[len(day_str)])
                    day -= relativedelta(months=2)
                    day = day.strftime({10: "%Y-%m-%d", 7: "%Y-%m", 4: "%Y"}[len(day_str)])
                    input_dates.append(day)

            # input_date가 현재 날짜와 동일한 경우
            elif input_date_compare == today:
                today = datetime.now(kst)
                one_year_ago  = today - relativedelta(years=1)
                one_month_ago = today - relativedelta(months=1)

                for day in input_date:
                    day_str = str(day)
                    if len(day_str) == 10:
                        input_dates.append(today.strftime("%Y-%m-%d"))

                    elif len(day_str) == 7:
                        start_date = one_month_ago + timedelta(days=1)
                        end_date = today
                        while start_date <= end_date:
                            input_dates.append(start_date.strftime("%Y-%m-%d"))
                            start_date += timedelta(days=1)

                    elif len(day_str) == 4:
                        start_date = one_year_ago + timedelta(days=1)
                        end_date = today
                        while start_date <= end_date:
                            input_dates.append(start_date.strftime("%Y-%m-%d"))
                            start_date += timedelta(days=1)

            # input_date가 현재 날짜보다 과거인 경우
            elif input_date_compare < today:
                input_dates.append(input_date[x])


    date_query = process_date_format(input_dates) if input_date else None
    return date_query

# 쿼리 추출 함수
def finance_create_query(text):

    entity = extract_finance_entities(text)
    entity1 = (entity['pattern1'])
    entity2 = (entity['pattern2'])

    original_input_date  = ed.split_and_return_periods(text, False)
    input_date = original_input_date

    if not input_date:
        input_date = datetime.now(kst).strftime("%Y-%m")

    date_query_fixed = process_fixed_dates_original(input_date, text)

    entity1pattern = []
    for i in range(len(entity1)):
        entity1pattern.append(entity1[i][1])
    entity1pattern = list(set(entity1pattern))

    if "STOCK" in entity1pattern or r"매입|매수|투자|판매|매매|매도|\b판\b|처분" in text:
        return pattern_stock(entity1, input_date, text=text)

    else:
        entity1pattern = filter_entities(entity1pattern)

        if len(entity1pattern) == 1:
            entity1pattern = entity1pattern[0]

        if entity1pattern == "지출" or entity1pattern == "소득" or r'구매|구입|\b산\b' in text:
            if "고정" in text:
                return finance_pattern_query(finance_query=entity1pattern, entity1=entity1, entity2=entity2, text=text, date_query=date_query_fixed)
            date_query = process_date_format(input_date)
            return finance_pattern_query(finance_query=entity1pattern, entity1=entity1, entity2=entity2, date_query=date_query, text=text)

        elif entity1pattern == "BUDGET":
            input_date = ed.split_and_return_periods(text, True)
            print(text)
            print(f'input_date {input_date}')
            if input_date == None:
                input_date = [datetime.strftime(datetime.today(), '%Y-%m')]
            input_month = input_date[0]
            return finance_pattern_query(entity1pattern, input_month, text=text, date_query=process_date_format(input_month))

        elif entity1pattern == "LOAN":
            date_query = process_date_format(input_date, date_type='%Y-%m')
            return finance_pattern_query(finance_query=entity1pattern, entity1=entity1, entity2=entity2, text=text, date_query=date_query)

        elif entity1pattern == "DEPOSIT_SAVINGS":
            date_query = process_date_format(input_date, date_type="%Y-%m-%d")
            return finance_pattern_query(finance_query=entity1pattern, entity1=entity1, entity2=entity2, date_query=date_query, text=text)

        elif entity1pattern == "입출금":
            date_query = process_date_format(input_date, date_type='%Y-%m')
            if "고정" in text:
                return finance_pattern_query(finance_query=entity1pattern, entity1=entity1, entity2=entity2, text=text, date_query=date_query_fixed)
            else:
                return finance_pattern_query(finance_query=entity1pattern, entity1=entity1, entity2=entity2, text=text, date_query=date_query)
        elif entity1pattern == "ASSET":
            return finance_pattern_query(finance_query=entity1pattern)

        elif entity1pattern == "ALL":
            date_query = process_date_format(input_date, date_type='%Y-%m')
            return finance_pattern_query(finance_query=entity1pattern, entity1=entity1, date_query=date_query, text=text)

        elif len(entity1pattern) == 0:
            query = { "예외": "질문에서 사용자의 의도파악에 실패하였습니다. 형식에 맞춰 다시 질문해주세요." }
            return query
        else:
            query = { "예외": "죄송합니다. 2개 이상의 재무정보는 한번에 답변이 불가능합니다. 1종류의 재무정보만 질문해주세요." }
            return query

def finance_clean_query(text):
    query = finance_create_query(text)
    complite_query = {}
    temp_value = set()
    for i, j in query.items():
        if j not in temp_value:
            complite_query[i] = j
            temp_value.add(j)
    return complite_query

def stockpricequery(text):
    entities = extract_stock_entities(text)
    stock_labels = ["삼성전자", "애플", "비트코인"]
    requested_stocks = [stock for stock in stock_labels if stock in entities]

    today      = datetime.now(kst)
    dates      = ed.split_and_return_periods(text, True)  # ['2024-09-25', '2024-09-26'] 혹은 None 반환 가능
    if dates:
        converted_dates = [
            kst.localize(datetime.strptime(date_str, '%Y' if len(date_str) == 4 else '%Y-%m' if len(date_str) == 7 else '%Y-%m-%d'))
            for date_str in dates if len(date_str) in [4, 7, 10]
        ]
        past_dates = [date for date in converted_dates if date <= today] if converted_dates else None
    else:
        past_dates = None

    # 미래 데이터만 있을 경우 메시지 반환
    if (past_dates is None or len(past_dates) == 0) and dates and len(dates) > 0:
        return "주식/코인에 대한 예상값은 다음 링크를 참조하세요: {PS_LINK}"

    # 날짜 조건 생성
    if not dates:
        date_condition = f"sp_date = '{today.strftime('%Y-%m-%d')}'"
    elif len(dates) == 1:
        date_condition = f"sp_date = '{dates[0]}'"
    else:
        date_condition = f"sp_date IN ('{', '.join([date for date in dates])}')"

    stocks_map = {
    "삼성전자": "sc_ss_stock",
    "애플": "sc_ap_stock",
    "비트코인": "sc_coin"
    }

    query = f"SELECT {stocks_map.get(requested_stocks[0], '')} FROM tb_stock WHERE {date_condition}" if requested_stocks else "해당 정보가 없습니다."
    return query if "주가" in entities and requested_stocks else "다시 질문해주시겠습니까?"
def stock_information_query(text):
    entities = extract_stock_entities(text)
    stock_map = {
        "삼성전자": {"PBR": "sc_ss_pbr", "PER": "sc_ss_per", "ROE": "sc_ss_roe", "MC": "sc_ss_mc"},
        "애플": {"PBR": "sc_ap_pbr", "PER": "sc_ap_per", "ROE": "sc_ap_roe", "MC": "sc_ap_mc"}
    }
    stock_labels = stock_map.keys()
    requested_stocks = [stock for stock in stock_labels if stock in entities]
    if not requested_stocks:
        return "해당 정보는 존재하지 않습니다."
    info_labels = ["PBR", "PER", "ROE", "MC"]

    requested_infos = [info for info in info_labels if info in entities]
    date = ed.split_and_return_periods(text)

    date_condition = (
    f"sp_date = '{datetime.now(kst).strftime('%Y-%m-%d')}'" if not date or date == []
    else f"sp_date = '{date[0]}'" if len(date) == 1
    else f"sp_date IN ('{', '.join(date)}')"
    )

    # SQL 쿼리 생성 및 답변 생성
    if requested_stocks and requested_infos:
        stock_info_column = stock_map.get(requested_stocks[0], {}).get(requested_infos[0])
        return f"SELECT {stock_info_column} FROM tb_stock WHERE {date_condition};" if stock_info_column else "해당 정보가 없습니다."

    return "올바른 주식 종목이나 정보를 제공해주세요."
def predict_stock_query():
    return "주식/코인에 대한 예상값은 다음 링크를 참조하세요: {PS_LINK}"
def economic_indicator_query():
    return "경제지표에 대한 자세한 정보는 다음 링크를 참조하세요: {EI_LINK}"

text = "오늘 삼성전자 PBR알려줘"
def stock_create_query(text):
    entity = extract_stock_entities(text)
    if len(entity) >= 3:
        return "하나의 질문만 해주세요."

    if "주가" in entity:
        stock_price = stockpricequery(text)
        return stock_price
    elif any(info in entity for info in ["PBR", "PER", "ROE", "MC"]):
        stock_info = stock_information_query(text)
        return stock_info
    elif "예상" in entity:
        predict_stock_query()
    elif "경제지표" in entity:
        economic = economic_indicator_query()
        return economic
    elif "증시" in entity:
        return "텍스트 파일 경로"

stock_create_query(text)

def make_query(intend, text):
    # predict = predict_label(text, model, tokenizer)
    if intend == 'finance':
        return finance_clean_query(text)
    elif intend == 'stock':
        return stock_create_query(text)
    elif intend == "FAQ":
        return FAQ_LINK

def budget_answer(query):
    if list(query.keys())[0] == "예산":
        month = datetime.now().strftime("%Y %m월")
        month_amount = f'{month} - {query["사용한 금액"]}'
        result = f"{month} 예산은 {query['예산']} 입니다. 사용 금액을 제외한 남은 금액은 {month_amount}"
        return result
    elif list(query.keys())[0] == "예산추천":
        result = f"예산 {query['예산추천']} 추천 드립니다. 예산 추천은 최근 3개월 소비를 분석하여 답변해드립니다."
        return result
    elif list(query.keys())[0] == "과거 예산 조회":
        return f"{query['과거 예산 조회']}"

